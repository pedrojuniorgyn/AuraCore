{
  "epic": "E7.8",
  "module": "WMS",
  "week": 2,
  "date": "2026-01-01",
  "total_bugs_found": 17,
  "total_bugs_fixed": 17,
  "categories": {
    "tenant_auth": 2,
    "http_status": 4,
    "persistence_order": 5,
    "silent_failures": 1,
    "di_tokens": 1,
    "domain_logic": 2,
    "concurrency": 1,
    "api_responses": 2,
    "data_consistency": 1
  },
  "bugs": [
    {
      "id": "Bug 1-2",
      "category": "tenant_auth",
      "description": "getTenantContext(request) pattern incorrect + branchId resolution",
      "files": ["src/app/api/wms/*/route.ts"],
      "correction": "Use getTenantContext() without params + resolveBranchIdOrThrow()",
      "status": "FIXED"
    },
    {
      "id": "Bug 3-4",
      "category": "http_status",
      "description": "Generic 400 for 'not found' errors",
      "files": ["src/app/api/wms/*/route.ts"],
      "correction": "Return 404 for 'not found', 409 for 'Insufficient stock'",
      "status": "FIXED"
    },
    {
      "id": "Bug 5",
      "category": "persistence_order",
      "description": "InventoryCount not persisted",
      "files": ["StartInventoryCount.ts", "CompleteInventoryCount.ts"],
      "correction": "Inject IInventoryCountRepository and call save()",
      "status": "FIXED"
    },
    {
      "id": "Bug 6",
      "category": "silent_failures",
      "description": "Silent failure in stock adjustment",
      "files": ["CompleteInventoryCount.ts"],
      "correction": "Check Result.isOk() for StockQuantity.create() and fail if error",
      "status": "FIXED"
    },
    {
      "id": "Bug 7",
      "category": "persistence_order",
      "description": "Movement saved before stock",
      "files": ["RegisterStockEntry.ts", "RegisterStockExit.ts", "TransferStock.ts"],
      "correction": "Save stock BEFORE movement (Stock-First Pattern)",
      "status": "FIXED"
    },
    {
      "id": "Bug 8",
      "category": "silent_failures",
      "description": "Silent failure in weighted average cost calculation",
      "files": ["RegisterStockEntry.ts", "TransferStock.ts"],
      "correction": "Check Money.create() result and return Result.fail() if error",
      "status": "FIXED"
    },
    {
      "id": "Bug 9",
      "category": "di_tokens",
      "description": "DI tokens removed but still used by Fiscal/Financial modules",
      "files": ["tokens.ts"],
      "correction": "Tokens were already present - no action needed",
      "status": "ALREADY_FIXED"
    },
    {
      "id": "Bug 10",
      "category": "persistence_order",
      "description": "CompleteInventoryCount violates Stock-First Pattern",
      "files": ["CompleteInventoryCount.ts"],
      "correction": "Reorder: Stock → Movement → InventoryCount",
      "status": "FIXED"
    },
    {
      "id": "Bug 11",
      "category": "domain_logic",
      "description": "Expired products cannot be loaded from database",
      "files": ["StockItem.ts", "DrizzleStockRepository.ts"],
      "correction": "Separate create() vs reconstitute() validation; add isExpired() method",
      "status": "FIXED"
    },
    {
      "id": "Bug 12",
      "category": "domain_logic",
      "description": "Date comparison with timestamp rejects products on expiration day",
      "files": ["StockItem.ts"],
      "correction": "Add isDateInPast() method that normalizes dates to midnight before comparing",
      "status": "FIXED"
    },
    {
      "id": "Bug 13",
      "category": "concurrency",
      "description": "StartInventoryCount allows duplicate records in concurrent requests",
      "files": ["StartInventoryCount.ts", "IInventoryCountRepository.ts", "DrizzleInventoryCountRepository.ts"],
      "correction": "Add findPendingByProductAndLocation() and check before creating",
      "status": "FIXED"
    },
    {
      "id": "Bug 14",
      "category": "domain_logic",
      "description": "TransferStock fails when transferring expired products to new location",
      "files": ["TransferStock.ts"],
      "correction": "Use reconstitute() instead of create() when creating stock item at destination (data already validated at original entry)",
      "status": "FIXED"
    },
    {
      "id": "Bug 15",
      "category": "api_responses",
      "description": "StartInventoryCount returns 400 for 'already in progress', should be 409 (Conflict)",
      "files": ["src/app/api/wms/inventory/route.ts"],
      "correction": "Created getHttpStatusFromError() helper and applied to all 6 WMS routes",
      "status": "FIXED"
    },
    {
      "id": "Bug 16",
      "category": "api_responses",
      "description": "CreateLocation returns 400 for 'already exists', should be 409 (Conflict)",
      "files": ["src/app/api/wms/locations/route.ts"],
      "correction": "Applied getHttpStatusFromError() helper (same as Bug 15)",
      "status": "FIXED"
    },
    {
      "id": "Bug 17",
      "category": "data_consistency",
      "description": "TransferStock saves source stock BEFORE completing destination operations. If destination fails (cost calculation or save), database is left inconsistent: source decremented but destination not updated. Result: stock 'disappeared' from system!",
      "files": ["src/modules/wms/application/use-cases/TransferStock.ts"],
      "correction": "Refactored to 3-phase pattern: PHASE 1: Fetch data (read-only); PHASE 2: Calculate and validate EVERYTHING in memory (no saves); PHASE 3: Persist ALL (only if PHASE 2 passed). Persistence order: Destination → Source → Movement",
      "severity": "CRITICAL",
      "impact": "Data integrity violation - financial reconciliation impossible",
      "status": "FIXED"
    }
  ],
  "patterns_created": [
    {
      "id": "ENFORCE-015",
      "name": "Date Comparison Pattern",
      "description": "Normalize dates to midnight before comparing to avoid timezone/hour issues"
    },
    {
      "id": "ENFORCE-016",
      "name": "Idempotency Check Pattern",
      "description": "Always verify existence before creating unique resources"
    },
    {
      "id": "ENFORCE-017",
      "name": "Reconstitute vs Create Validation",
      "description": "create() validates business rules; reconstitute() only validates structural integrity"
    },
    {
      "id": "ENFORCE-018",
      "name": "Transfer Uses Reconstitute Pattern",
      "description": "When transferring/moving entities between locations, use reconstitute() for destination (data already validated at original entry)"
    },
    {
      "id": "ENFORCE-019",
      "name": "HTTP Status Code Pattern",
      "description": "Map errors to correct HTTP status codes: 404 (not found), 409 (conflict/already exists/insufficient), 401 (unauthorized), 403 (forbidden), 400 (validation)"
    },
    {
      "id": "ENFORCE-020",
      "name": "Calculate Before Persist Pattern",
      "description": "In multi-step operations, ALL validations and calculations must be done BEFORE any persistence. If any calculation fails, no data should have been modified in database. Pattern: PHASE 1: Fetch (read-only); PHASE 2: Calculate & Validate (in-memory); PHASE 3: Persist (only if PHASE 2 passed)"
    }
  ],
  "lessons_learned": [
    "SEMPRE consultar MCP antes de implementar novos use cases",
    "SEMPRE verificar existência antes de criar recursos únicos (idempotency)",
    "SEMPRE separar validação de create() vs reconstitute()",
    "SEMPRE comparar datas normalizadas para meia-noite (sem hora)",
    "SEMPRE verificar uso de tokens DI antes de remover",
    "SEMPRE salvar estoque ANTES de movimento (Stock-First Pattern)",
    "SEMPRE propagar erros de Money.create() e StockQuantity.create()",
    "SEMPRE retornar HTTP status correto (404 para 'not found', 409 para conflito)",
    "SEMPRE usar getTenantContext() sem parâmetros + resolveBranchIdOrThrow()",
    "SEMPRE persistir entidades relacionadas (InventoryCount, não apenas StockItem)",
    "SEMPRE criar helper para lógica repetida (ex: getHttpStatusFromError)",
    "SEMPRE aplicar padrões consistentemente em todas as rotas relacionadas",
    "NUNCA salvar dados parciais - calcular TUDO antes de persistir QUALQUER COISA",
    "SEMPRE seguir 3 fases: Buscar → Calcular/Validar → Persistir",
    "SEMPRE considerar: 'O que acontece se esta linha falhar? Já salvei algo?'"
  ],
  "root_causes": [
    "Falta de consulta aos contratos MCP antes de codificar",
    "Padrões não sendo seguidos consistentemente",
    "Edge cases não considerados (concorrência, datas, produtos expirados)",
    "Validação insuficiente de requisitos de negócio",
    "Testes não cobrindo cenários de concorrência e edge cases",
    "Pensamento sequencial ao invés de atomicidade em operações multi-step",
    "Falta de análise: 'E se falhar AQUI? O que já salvei?'"
  ],
  "prevention_measures": [
    "Adicionar ENFORCE-015, 016, 017, 018, 019, 020 ao type-safety.json",
    "Criar testes para cenários de concorrência",
    "Criar testes para produtos expirados (hoje, ontem, amanhã)",
    "Revisar todos os use cases para idempotency",
    "Adicionar lint rule para detectar comparação de datas sem normalização",
    "Criar helpers para lógica repetida (ex: error status mapping)",
    "Code review focado em consistência de padrões entre rotas similares",
    "Criar lint rule: detectar 'await.*save' seguido de cálculos/validações",
    "Template obrigatório para use cases multi-step: FASE 1 → FASE 2 → FASE 3",
    "Análise obrigatória: marcar TODAS as linhas que podem falhar APÓS primeiro save"
  ]
}

