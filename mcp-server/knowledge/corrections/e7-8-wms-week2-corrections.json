{
  "epic": "E7.8",
  "module": "WMS",
  "week": 2,
  "date": "2026-01-01",
  "total_bugs_found": 20,
  "total_bugs_fixed": 20,
  "categories": {
    "tenant_auth": 2,
    "http_status": 4,
    "persistence_order": 5,
    "silent_failures": 1,
    "di_tokens": 1,
    "domain_logic": 2,
    "concurrency": 1,
    "api_responses": 2,
    "data_consistency": 2,
    "financial_integrity": 1,
    "validation_consistency": 1,
    "fail_fast_violation": 1
  },
  "bugs": [
    {
      "id": "Bug 1-2",
      "category": "tenant_auth",
      "description": "getTenantContext(request) pattern incorrect + branchId resolution",
      "files": ["src/app/api/wms/*/route.ts"],
      "correction": "Use getTenantContext() without params + resolveBranchIdOrThrow()",
      "status": "FIXED"
    },
    {
      "id": "Bug 3-4",
      "category": "http_status",
      "description": "Generic 400 for 'not found' errors",
      "files": ["src/app/api/wms/*/route.ts"],
      "correction": "Return 404 for 'not found', 409 for 'Insufficient stock'",
      "status": "FIXED"
    },
    {
      "id": "Bug 5",
      "category": "persistence_order",
      "description": "InventoryCount not persisted",
      "files": ["StartInventoryCount.ts", "CompleteInventoryCount.ts"],
      "correction": "Inject IInventoryCountRepository and call save()",
      "status": "FIXED"
    },
    {
      "id": "Bug 6",
      "category": "silent_failures",
      "description": "Silent failure in stock adjustment",
      "files": ["CompleteInventoryCount.ts"],
      "correction": "Check Result.isOk() for StockQuantity.create() and fail if error",
      "status": "FIXED"
    },
    {
      "id": "Bug 7",
      "category": "persistence_order",
      "description": "Movement saved before stock",
      "files": ["RegisterStockEntry.ts", "RegisterStockExit.ts", "TransferStock.ts"],
      "correction": "Save stock BEFORE movement (Stock-First Pattern)",
      "status": "FIXED"
    },
    {
      "id": "Bug 8",
      "category": "silent_failures",
      "description": "Silent failure in weighted average cost calculation",
      "files": ["RegisterStockEntry.ts", "TransferStock.ts"],
      "correction": "Check Money.create() result and return Result.fail() if error",
      "status": "FIXED"
    },
    {
      "id": "Bug 9",
      "category": "di_tokens",
      "description": "DI tokens removed but still used by Fiscal/Financial modules",
      "files": ["tokens.ts"],
      "correction": "Tokens were already present - no action needed",
      "status": "ALREADY_FIXED"
    },
    {
      "id": "Bug 10",
      "category": "persistence_order",
      "description": "CompleteInventoryCount violates Stock-First Pattern",
      "files": ["CompleteInventoryCount.ts"],
      "correction": "Reorder: Stock → Movement → InventoryCount",
      "status": "FIXED"
    },
    {
      "id": "Bug 11",
      "category": "domain_logic",
      "description": "Expired products cannot be loaded from database",
      "files": ["StockItem.ts", "DrizzleStockRepository.ts"],
      "correction": "Separate create() vs reconstitute() validation; add isExpired() method",
      "status": "FIXED"
    },
    {
      "id": "Bug 12",
      "category": "domain_logic",
      "description": "Date comparison with timestamp rejects products on expiration day",
      "files": ["StockItem.ts"],
      "correction": "Add isDateInPast() method that normalizes dates to midnight before comparing",
      "status": "FIXED"
    },
    {
      "id": "Bug 13",
      "category": "concurrency",
      "description": "StartInventoryCount allows duplicate records in concurrent requests",
      "files": ["StartInventoryCount.ts", "IInventoryCountRepository.ts", "DrizzleInventoryCountRepository.ts"],
      "correction": "Add findPendingByProductAndLocation() and check before creating",
      "status": "FIXED"
    },
    {
      "id": "Bug 14",
      "category": "domain_logic",
      "description": "TransferStock fails when transferring expired products to new location",
      "files": ["TransferStock.ts"],
      "correction": "Use reconstitute() instead of create() when creating stock item at destination (data already validated at original entry)",
      "status": "FIXED"
    },
    {
      "id": "Bug 15",
      "category": "api_responses",
      "description": "StartInventoryCount returns 400 for 'already in progress', should be 409 (Conflict)",
      "files": ["src/app/api/wms/inventory/route.ts"],
      "correction": "Created getHttpStatusFromError() helper and applied to all 6 WMS routes",
      "status": "FIXED"
    },
    {
      "id": "Bug 16",
      "category": "api_responses",
      "description": "CreateLocation returns 400 for 'already exists', should be 409 (Conflict)",
      "files": ["src/app/api/wms/locations/route.ts"],
      "correction": "Applied getHttpStatusFromError() helper (same as Bug 15)",
      "status": "FIXED"
    },
    {
      "id": "Bug 17",
      "category": "data_consistency",
      "description": "TransferStock saves source stock BEFORE completing destination operations. If destination fails (cost calculation or save), database is left inconsistent: source decremented but destination not updated. Result: stock 'disappeared' from system!",
      "files": ["src/modules/wms/application/use-cases/TransferStock.ts"],
      "correction": "Refactored to 3-phase pattern: PHASE 1: Fetch data (read-only); PHASE 2: Calculate and validate EVERYTHING in memory (no saves); PHASE 3: Persist ALL (only if PHASE 2 passed). Persistence order: Destination → Source → Movement",
      "severity": "CRITICAL",
      "impact": "Data integrity violation - financial reconciliation impossible",
      "status": "FIXED"
    },
    {
      "id": "Bug 18",
      "category": "financial_integrity",
      "description": "When creating new stock at destination location during transfer, code uses fromStockItem.unitCost instead of pre-calculated destinationUnitCost variable. This bypasses weighted average cost calculation when toStockItem doesn't exist, causing incorrect financial data. The destinationUnitCost was calculated at lines 103-119 but only applied when existing destination stock was present, not when creating new destination stock.",
      "files": ["src/modules/wms/application/use-cases/TransferStock.ts"],
      "correction": "Changed line 161 to use destinationUnitCost (calculated variable) instead of fromStockItem.unitCost. Pattern: ALWAYS use calculated variables in ALL subsequent places, even if value seems equal. This ensures consistency and prevents bugs when calculation logic is modified. Pattern registered as ENFORCE-021 in MCP.",
      "severity": "HIGH",
      "impact": "Incorrect unit cost for new destination stock - financial reports inaccurate",
      "status": "FIXED"
    },
    {
      "id": "Bug 19",
      "category": "validation_consistency",
      "description": "RegisterStockExit validates that location exists but does NOT check if location.isActive before allowing stock exit. In contrast, RegisterStockEntry checks location.isActive and TransferStock validates both source and destination locations are active. This inconsistency allows stock exits from inactive locations, violating expected business rule that operations should only occur at active locations.",
      "files": ["src/modules/wms/application/use-cases/RegisterStockExit.ts"],
      "correction": "Added location.isActive validation after location exists check (line 42-44). Pattern: ALWAYS apply SAME validations to similar operations. Created template: 1) Check exists, 2) Check isActive. Applied to ALL stock operations (Entry, Exit, Transfer). Pattern registered as ENFORCE-022 in MCP.",
      "severity": "MEDIUM",
      "impact": "Business rule violation - allows operations on inactive locations",
      "status": "FIXED"
    },
    {
      "id": "Bug 20",
      "category": "fail_fast_violation",
      "description": "CreateLocationSchema DTO makes parentId optional for ALL types, but Location.create() domain method requires non-WAREHOUSE types (AISLE, SHELF, POSITION) to have a parent. The CreateLocation use case only validates parentId IF provided, leaving gap where clients can submit AISLE/SHELF/POSITION without parent. This violates fail-fast principle: validation should happen in Use Case BEFORE calling domain, not let domain reject with generic error.",
      "files": [
        "src/modules/wms/application/use-cases/CreateLocation.ts",
        "src/modules/wms/application/dtos/CreateLocationDTO.ts"
      ],
      "correction": "Added fail-fast validation in Use Case: 1) If type !== WAREHOUSE && !parentId, return fail. 2) If type === WAREHOUSE && parentId, return fail. Also added .refine() to DTO schema for conditional validation. Validation order established: DTO format → Use Case business rules → Repository existence → Domain invariants. Pattern registered as ENFORCE-023 in MCP.",
      "severity": "MEDIUM",
      "impact": "Poor error messages, unnecessary domain operations, violation of separation of concerns",
      "status": "FIXED"
    }
  ],
  "patterns_created": [
    {
      "id": "ENFORCE-015",
      "name": "Date Comparison Pattern",
      "description": "Normalize dates to midnight before comparing to avoid timezone/hour issues"
    },
    {
      "id": "ENFORCE-016",
      "name": "Idempotency Check Pattern",
      "description": "Always verify existence before creating unique resources"
    },
    {
      "id": "ENFORCE-017",
      "name": "Reconstitute vs Create Validation",
      "description": "create() validates business rules; reconstitute() only validates structural integrity"
    },
    {
      "id": "ENFORCE-018",
      "name": "Transfer Uses Reconstitute Pattern",
      "description": "When transferring/moving entities between locations, use reconstitute() for destination (data already validated at original entry)"
    },
    {
      "id": "ENFORCE-019",
      "name": "HTTP Status Code Pattern",
      "description": "Map errors to correct HTTP status codes: 404 (not found), 409 (conflict/already exists/insufficient), 401 (unauthorized), 403 (forbidden), 400 (validation)"
    },
    {
      "id": "ENFORCE-020",
      "name": "Calculate Before Persist Pattern",
      "description": "In multi-step operations, ALL validations and calculations must be done BEFORE any persistence. If any calculation fails, no data should have been modified in database. Pattern: PHASE 1: Fetch (read-only); PHASE 2: Calculate & Validate (in-memory); PHASE 3: Persist (only if PHASE 2 passed)"
    },
    {
      "id": "ENFORCE-021",
      "name": "Use Calculated Variables Pattern",
      "description": "When a value is calculated and stored in a variable (ex: destinationUnitCost), ALWAYS use that variable in ALL subsequent places, even if the original value seems equal. Guarantees consistency and prevents bugs when calculation logic is modified."
    },
    {
      "id": "ENFORCE-022",
      "name": "Consistent Business Validations Pattern",
      "description": "Similar operations (Entry, Exit, Transfer) MUST have identical validation patterns. Template for location operations: 1) Check exists, 2) Check isActive. Inconsistencies create bugs and maintenance nightmares."
    },
    {
      "id": "ENFORCE-023",
      "name": "Fail-Fast Business Rules Validation Pattern",
      "description": "Validations that CAN be done before calling domain MUST be done in Use Case. Order: 1) Format (DTO), 2) Simple business rules (Use Case), 3) Existence (Repository), 4) Complex invariants (Domain). Improves error messages and avoids unnecessary operations."
    }
  ],
  "lessons_learned": [
    "SEMPRE consultar MCP antes de implementar novos use cases",
    "SEMPRE verificar existência antes de criar recursos únicos (idempotency)",
    "SEMPRE separar validação de create() vs reconstitute()",
    "SEMPRE comparar datas normalizadas para meia-noite (sem hora)",
    "SEMPRE verificar uso de tokens DI antes de remover",
    "SEMPRE salvar estoque ANTES de movimento (Stock-First Pattern)",
    "SEMPRE propagar erros de Money.create() e StockQuantity.create()",
    "SEMPRE retornar HTTP status correto (404 para 'not found', 409 para conflito)",
    "SEMPRE usar getTenantContext() sem parâmetros + resolveBranchIdOrThrow()",
    "SEMPRE persistir entidades relacionadas (InventoryCount, não apenas StockItem)",
    "SEMPRE criar helper para lógica repetida (ex: getHttpStatusFromError)",
    "SEMPRE aplicar padrões consistentemente em todas as rotas relacionadas",
    "NUNCA salvar dados parciais - calcular TUDO antes de persistir QUALQUER COISA",
    "SEMPRE seguir 3 fases: Buscar → Calcular/Validar → Persistir",
    "SEMPRE considerar: 'O que acontece se esta linha falhar? Já salvei algo?'",
    "SEMPRE usar variáveis calculadas em TODOS os lugares subsequentes",
    "NUNCA misturar uso de variável calculada e variável original (ex: destinationUnitCost vs fromStockItem.unitCost)",
    "SEMPRE aplicar validações IDÊNTICAS em operações similares (Entry, Exit, Transfer)",
    "SEMPRE criar template de validação para operações do mesmo tipo",
    "SEMPRE validar regras de negócio simples no Use Case ANTES de chamar domínio (fail-fast)",
    "SEMPRE seguir ordem: DTO format → Use Case business rules → Repository existence → Domain invariants"
  ],
  "root_causes": [
    "Falta de consulta aos contratos MCP antes de codificar",
    "Padrões não sendo seguidos consistentemente",
    "Edge cases não considerados (concorrência, datas, produtos expirados)",
    "Validação insuficiente de requisitos de negócio",
    "Testes não cobrindo cenários de concorrência e edge cases",
    "Pensamento sequencial ao invés de atomicidade em operações multi-step",
    "Falta de análise: 'E se falhar AQUI? O que já salvei?'",
    "Copy-paste de código sem adaptar para contexto (usar original ao invés de calculado)",
    "Falta de revisão: 'Por que calculei isso se não vou usar?'",
    "Implementação parcial de validações (copiar parte do código, esquecer validações)",
    "Falta de comparação entre use cases similares durante code review",
    "Deixar validações simples para o domínio ao invés de validar no Use Case",
    "Não perguntar: 'Esta validação poderia ser feita ANTES de chamar o domínio?'"
  ],
  "prevention_measures": [
    "Adicionar ENFORCE-015, 016, 017, 018, 019, 020, 021 ao type-safety.json",
    "Criar testes para cenários de concorrência",
    "Criar testes para produtos expirados (hoje, ontem, amanhã)",
    "Revisar todos os use cases para idempotency",
    "Adicionar lint rule para detectar comparação de datas sem normalização",
    "Criar helpers para lógica repetida (ex: error status mapping)",
    "Code review focado em consistência de padrões entre rotas similares",
    "Criar lint rule: detectar 'await.*save' seguido de cálculos/validações",
    "Template obrigatório para use cases multi-step: FASE 1 → FASE 2 → FASE 3",
    "Análise obrigatória: marcar TODAS as linhas que podem falhar APÓS primeiro save",
    "Criar lint rule: detectar variável calculada (const.*=.*calculate) não usada em todos locais",
    "Code review: verificar que variáveis calculadas são usadas consistentemente",
    "Template obrigatório para validações de localização: exists → isActive",
    "Code review: comparar side-by-side use cases similares para garantir validações idênticas",
    "Template de ordem de validação: DTO → Use Case → Repository → Domain",
    "Code review: verificar se validações simples estão no Use Case (fail-fast) e não apenas no domínio"
  ]
}

