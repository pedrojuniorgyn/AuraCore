{
  "epic": "E8.5",
  "corrections": [
    {
      "id": "LC-649449",
      "date": "2026-02-05",
      "epic": "E8.5",
      "error": "BaseGrid's mobileColumns filter usa field.includes(mobileCol) para filtrar colunas em mobile. Colunas de Ações sem propriedade 'field' eram convertidas para string vazia, causando exclusão da coluna e tornando botões de ação inacessíveis em dispositivos móveis.",
      "correction": "Adicionado field: 'actions' na definição de coluna de Ações em todos os grids estratégicos (ActionPlanGrid, PDCAGrid, SWOTGrid, IdeasGrid)",
      "files_affected": [
        "src/components/strategic/ActionPlanGrid.tsx",
        "src/components/strategic/pdca/PDCAGrid.tsx",
        "src/components/strategic/swot/SWOTGrid.tsx",
        "src/components/strategic/ideas/IdeasGrid.tsx"
      ],
      "pattern_created": "GRID-MOBILE-ACTIONS-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-741543",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "React Error #418 - Hydration mismatch no AIInsightWidget. toLocaleTimeString() gera valores diferentes entre servidor (SSR) e cliente (CSR) devido a timezones diferentes, causando HTML diferente e falha de hydration.",
      "correction": "Adicionado useState para formattedTime + useEffect para formatar timestamp apenas no cliente. Renderização condicional com {formattedTime && ...} garante que timestamp só aparece após hydration completa.",
      "files_affected": [
        "src/components/ai/AIInsightWidget.tsx"
      ],
      "pattern_created": "HYDRATION-CLIENT-ONLY-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-945806",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "adjustedTotal no findMany criava contrato de paginação inconsistente: subtraía erros de mapeamento do total, mas cada página poderia ter taxas de erro diferentes, causando totais inconsistentes entre páginas (ex: pág1=98, pág2=100, pág3=95)",
      "correction": "Removido adjustedTotal e retornado total original. Erros de mapeamento devem ser logados para correção de dados, não escondidos manipulando o total. Contrato de paginação agora é consistente.",
      "files_affected": [
        "src/modules/strategic/okr/infrastructure/persistence/repositories/DrizzleOkrRepository.ts"
      ],
      "pattern_created": "PAGINATION-TOTAL-INTEGRITY-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-447015",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "Fix anterior usava suppressHydrationWarning que apenas mascara o problema. O timestamp ainda mostrava valor incorreto dependendo da timezone do servidor vs cliente. O toLocaleTimeString() continuava gerando HTML diferente.",
      "correction": "Criado hook useClientFormattedTime usando useSyncExternalStore do React 18 para formatar timestamps apenas no cliente. Hook retorna string vazia no servidor e formata após hydration, garantindo timezone correta do usuário.",
      "files_affected": [
        "src/hooks/useClientFormattedTime.ts",
        "src/components/ai/AIInsightWidget.tsx"
      ],
      "pattern_created": "HYDRATION-USESYNCEXTERNALSTORE-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-280464",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "Botão Edit no ActionPlanGrid navegava para /strategic/action-plans/[id]/edit que não existe, causando 404. A página de detalhes já possui edição inline.",
      "correction": "Removido /edit do caminho de navegação. onEdit agora navega para /strategic/action-plans/[id] (página de detalhes com edição inline).",
      "files_affected": [
        "src/components/strategic/ActionPlanGrid.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-525293",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "Fix anterior fazia onView e onEdit navegarem para a mesma URL, perdendo distinção de UX entre visualizar e editar. ActionPlanGrid não tem rota /[id]/edit como outros grids (PDCA, SWOT, Ideas).",
      "correction": "onEdit navega com query param ?edit=true. Página de detalhes lê searchParams e ativa isEditing5W2H automaticamente quando edit=true, mantendo distinção de UX.",
      "files_affected": [
        "src/components/strategic/ActionPlanGrid.tsx",
        "src/app/(dashboard)/strategic/action-plans/[id]/page.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-651607",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "Após exclusão de OKR (ou qualquer recurso), lista não atualizava automaticamente. router.push() ocorria antes do cache Next.js ser atualizado, causando race condition com router.refresh() no hook useDeleteResource.",
      "correction": "Adicionado setTimeout(() => router.refresh(), 100) após router.push() em DeleteResourceButton e DeleteResourceButtonCompact, garantindo refresh após navegação completar.",
      "files_affected": [
        "src/components/strategic/DeleteResourceButton.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-422001",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "3 bugs em fixes anteriores: 1) isEditing5W2H só setava true, nunca false - dessincronizava UI com URL 2) searchParams no dependency array causava infinite loop (nova referência a cada render) 3) setTimeout(100ms) antes de router.refresh() criava race condition",
      "correction": "1) setIsEditing5W2H(editMode) sincroniza bidirecional com query param 2) Extraída primitiva editMode = searchParams.get('edit') === 'true' como dependency 3) Removido setTimeout, router.refresh() chamado diretamente após router.push() (padrão do codebase)",
      "files_affected": [
        "src/app/(dashboard)/strategic/action-plans/[id]/page.tsx",
        "src/components/strategic/DeleteResourceButton.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-134372",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "2 bugs em fix anterior: 1) router no dependency array do useEffect causa re-renders infinitos porque useRouter() retorna nova referência a cada render 2) handle5W2HSave e handle5W2HCancel setavam isEditing5W2H=false mas não limpavam ?edit=true da URL, causando dessincronização após refresh",
      "correction": "1) Removido router do dependency array com eslint-disable comment explicando que router é estável 2) Adicionado router.replace() com scroll:false em handle5W2HSave e handle5W2HCancel para limpar query param da URL",
      "files_affected": [
        "src/app/(dashboard)/strategic/action-plans/[id]/page.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-306452",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "router.refresh() duplicado em DeleteResourceButton: hook useDeleteResource já chama refresh() após DELETE bem-sucedido (linha 160), mas componente chamava novamente no onSuccess. Isso criava race condition onde refresh podia executar na rota antiga antes da navegação completar.",
      "correction": "Removido router.refresh() de DeleteResourceButton e DeleteResourceButtonCompact. O hook useDeleteResource já faz refresh, e router.push() para nova página busca dados frescos automaticamente.",
      "files_affected": [
        "src/components/strategic/DeleteResourceButton.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-833119",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "useSearchParams() chamado diretamente sem Suspense boundary. No Next.js 15, useSearchParams() não está disponível durante SSR e requer Suspense boundary para evitar hydration mismatch. Padrão do codebase (visto em /new/page.tsx) envolve useSearchParams em componente separado dentro de Suspense.",
      "correction": "Extraída lógica para ActionPlanDetailPageContent e criado wrapper ActionPlanDetailPage com Suspense boundary e fallback de loading. Segue padrão de /new/page.tsx.",
      "files_affected": [
        "src/app/(dashboard)/strategic/action-plans/[id]/page.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-878325",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "useSearchParams() chamado sem Suspense boundary em 2 arquivos adicionais: user-auth-form.tsx (login) e okrs/new/page.tsx. No Next.js 15, useSearchParams() requer Suspense boundary para evitar hydration mismatch.",
      "correction": "Aplicado mesmo padrão de action-plans: extraída lógica para componente Content interno e criado wrapper com Suspense boundary e fallback de loading.",
      "files_affected": [
        "src/app/(auth)/login/user-auth-form.tsx",
        "src/app/(dashboard)/strategic/okrs/new/page.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-101662",
      "date": "2026-02-06",
      "epic": "E8.5",
      "error": "2 bugs no useEffect: 1) editMode no dependency array causava re-fetch quando router.replace() limpava a URL após save/cancel, resultando em chamadas API desnecessárias e re-inicialização do formulário 2) Botão Edit apenas setava estado sem atualizar URL, perdendo modo de edição após page refresh",
      "correction": "1) Separado efeito de fetch (depende apenas de id) do efeito de editMode sync (depende de editMode) 2) Botão Edit agora usa router.push() com ?edit=true para manter URL sincronizada com estado",
      "files_affected": [
        "src/app/(dashboard)/strategic/action-plans/[id]/page.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-015434",
      "date": "2026-02-07",
      "epic": "E8.5",
      "error": "React Error #418 - Hydration mismatch em 9 páginas do módulo Strategic. toLocaleDateString() e toLocaleTimeString() geravam valores diferentes entre servidor (SSR) e cliente (CSR) devido a timezones diferentes, causando HTML diferente e falha de hydration em páginas Next.js 15.",
      "correction": "Implementado padrão consistente usando hooks useClientFormattedDate/useClientFormattedTime (LC-447015) em todas as 9 páginas. Hooks chamados ANTES de early returns (Rules of Hooks). Para casos em loops/maps, criados componentes auxiliares (DecisionDeadline, SubmittedDate, DecidedDate) que encapsulam os hooks corretamente.",
      "files_affected": [
        "src/app/(dashboard)/strategic/okrs/[id]/page.tsx",
        "src/app/(dashboard)/strategic/action-plans/[id]/page.tsx",
        "src/app/(dashboard)/strategic/goals/[id]/page.tsx",
        "src/app/(dashboard)/strategic/war-room/page.tsx",
        "src/app/(dashboard)/strategic/pdca/[id]/page.tsx",
        "src/app/(dashboard)/strategic/swot/[id]/page.tsx",
        "src/app/(dashboard)/strategic/ideas/[id]/page.tsx",
        "src/app/(dashboard)/strategic/war-room/meetings/[id]/page.tsx",
        "src/app/(dashboard)/strategic/approvals/page.tsx"
      ],
      "pattern_created": "HYDRATION-BATCH-FIX-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-593679",
      "date": "2026-02-07",
      "epic": "E8.5",
      "error": "Hook calls em war-room/meetings/[id]/page.tsx referenciavam propriedades incorretas: meeting?.scheduledDate (deveria ser scheduledAt) e meeting?.endTime (deveria ser endedAt). Isso causava fallback para new Date(), exibindo data/hora atual ao invés da data real da reunião.",
      "correction": "Corrigidas 3 ocorrências: scheduledDate → scheduledAt (2x) e endTime → endedAt (1x). Agora os hooks recebem as propriedades corretas da interface MeetingDetail e exibem as datas reais das reuniões.",
      "files_affected": [
        "src/app/(dashboard)/strategic/war-room/meetings/[id]/page.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-192580",
      "date": "2026-02-07",
      "epic": "E8.5",
      "error": "formattedEndTime em war-room/meetings/[id]/page.tsx era definido mas nunca usado na UI (código morto). Quando meeting.endedAt é null (reuniões em andamento/agendadas), o hook formatava hora atual ao invés de não exibir nada, causando computação desnecessária e potencial confusão se fosse renderizado no futuro.",
      "correction": "Removido hook formattedEndTime não utilizado. Adicionado comentário com padrão correto para implementação futura: verificar meeting?.endedAt antes de renderizar tempo formatado. Pattern: {meeting?.endedAt && formattedEndTime && <Text>{formattedEndTime}</Text>}",
      "files_affected": [
        "src/app/(dashboard)/strategic/war-room/meetings/[id]/page.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-926575",
      "date": "2026-02-07",
      "epic": "E8.5",
      "error": "CRÍTICO: Implementação anterior das correções de hydration (LC-015434) usava renderização condicional {formatted && <Element>} que CAUSAVA hydration mismatch ao invés de prevenir. Servidor renderizava nada (string vazia = falsy), cliente renderizava elemento (string formatada = truthy), resultando em estruturas DOM diferentes e React Error #418 em TODAS as 9 páginas corrigidas.",
      "correction": "Corrigido padrão de renderização para SEMPRE renderizar elemento container, apenas variando o conteúdo: <Element>{formatted || '\\u00A0'}</Element>. Aplicado em 10 arquivos: 8 páginas + 3 componentes auxiliares (DecisionDeadline, SubmittedDate, DecidedDate). Pattern correto: elemento sempre renderizado com '\\u00A0' (non-breaking space) como placeholder no servidor.",
      "files_affected": [
        "src/app/(dashboard)/strategic/war-room/meetings/[id]/page.tsx",
        "src/app/(dashboard)/strategic/pdca/[id]/page.tsx",
        "src/app/(dashboard)/strategic/okrs/[id]/page.tsx",
        "src/app/(dashboard)/strategic/goals/[id]/page.tsx",
        "src/app/(dashboard)/strategic/action-plans/[id]/page.tsx",
        "src/app/(dashboard)/strategic/swot/[id]/page.tsx",
        "src/app/(dashboard)/strategic/war-room/page.tsx",
        "src/app/(dashboard)/strategic/ideas/[id]/page.tsx",
        "src/app/(dashboard)/strategic/approvals/page.tsx"
      ],
      "pattern_created": "HYDRATION-ALWAYS-RENDER-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-762146",
      "date": "2026-02-07",
      "epic": "E8.5",
      "error": "CRÍTICO: Hook calls usavam pattern 'data?.property || new Date()' que criava novo objeto Date a CADA render quando data é null. Durante loading, hook recebia timestamps diferentes (hora atual avançando), causando toLocaleTimeString() retornar strings diferentes e gerando flickering visual, derrotando o propósito da correção de hydration.",
      "correction": "Substituído new Date() por new Date(0) (epoch estático) em todos os fallbacks. new Date(0) retorna valor constante (1970-01-01 00:00:00 UTC) que não muda entre renders, eliminando flickering durante loading. Aplicado em 7 arquivos com 11 hooks calls afetados: pdca, okrs, goals, action-plans, swot, war-room meetings, ideas.",
      "files_affected": [
        "src/app/(dashboard)/strategic/pdca/[id]/page.tsx",
        "src/app/(dashboard)/strategic/okrs/[id]/page.tsx",
        "src/app/(dashboard)/strategic/goals/[id]/page.tsx",
        "src/app/(dashboard)/strategic/action-plans/[id]/page.tsx",
        "src/app/(dashboard)/strategic/swot/[id]/page.tsx",
        "src/app/(dashboard)/strategic/war-room/meetings/[id]/page.tsx",
        "src/app/(dashboard)/strategic/ideas/[id]/page.tsx"
      ],
      "pattern_created": "HYDRATION-STATIC-FALLBACK-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-161293",
      "date": "2026-02-07",
      "epic": "E8.5",
      "error": "CRÍTICO: Pattern condicional verificava strings formatadas (formattedDate && ...) ao invés dos dados originais (data?.property). Durante hydration, hooks já retornam valores formatados no cliente via useSyncExternalStore, causando conteúdo textual diferente entre servidor ('\\u00A0') e cliente (datas formatadas), gerando React Error #418 mesmo com estrutura DOM idêntica.",
      "correction": "Substituído pattern {formatted && ... ? ... : '\\u00A0'} por {data?.property && ... ? formattedString : '\\u00A0'}. Agora verifica se DADOS ORIGINAIS existem (não strings formatadas), garantindo conteúdo idêntico durante hydration inicial: servidor e cliente ambos renderizam '\\u00A0' até dados carregarem. Aplicado em okrs/[id] e action-plans/[id].",
      "files_affected": [
        "src/app/(dashboard)/strategic/okrs/[id]/page.tsx",
        "src/app/(dashboard)/strategic/action-plans/[id]/page.tsx",
        "src/app/(dashboard)/strategic/war-room/meetings/[id]/page.tsx"
      ],
      "pattern_created": "HYDRATION-CHECK-ORIGINAL-DATA-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-327861",
      "date": "2026-02-07",
      "epic": "E8.5",
      "error": "CRÍTICO (extensão de LC-161293): Pattern {formatted || '\\u00A0'} também causa hydration mismatch porque verifica strings formatadas ao invés de dados originais. Durante hydration, hooks useSyncExternalStore retornam valores formatados no cliente mas string vazia no servidor, causando conteúdo textual diferente. Encontrado em 5 páginas adicionais (goals, ideas, pdca, swot, approvals) e war-room/page.tsx com useState(new Date()) que gera timestamps diferentes entre renders.",
      "correction": "Aplicado pattern correto {data?.property ? formatted : '\\u00A0'} em goals, ideas, pdca, swot. Para war-room/page.tsx: substituído useState(new Date()) por useState(new Date(0)) para evitar timestamps diferentes. Para approvals helper components: simplificado para {formatted || '\\u00A0'} pois não há dados originais para verificar (componentes assumem date sempre válido). Pattern HYDRATION-CHECK-ORIGINAL-DATA aplica-se quando há dados originais disponíveis para verificação condicional.",
      "files_affected": [
        "src/app/(dashboard)/strategic/goals/[id]/page.tsx",
        "src/app/(dashboard)/strategic/ideas/[id]/page.tsx",
        "src/app/(dashboard)/strategic/pdca/[id]/page.tsx",
        "src/app/(dashboard)/strategic/swot/[id]/page.tsx",
        "src/app/(dashboard)/strategic/approvals/page.tsx",
        "src/app/(dashboard)/strategic/war-room/page.tsx"
      ],
      "pattern_created": "HYDRATION-CHECK-ORIGINAL-DATA-002",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-029586",
      "date": "2026-02-07",
      "epic": "E8.5",
      "error": "Bug introduzido em LC-327861: Helper components SubmittedDate e DecidedDate tiveram labels \"Submetida em:\" e \"Decidida em:\" removidos durante simplificação do pattern de hydration. Components renderizavam apenas timestamps sem contexto, tornando UI ambígua (não ficava claro qual timestamp era submissão vs. decisão).",
      "correction": "Restaurados labels dentro dos helper components mantendo pattern correto de hydration. SubmittedDate agora renderiza {formatted ? `Submetida em: ${formatted}` : '\\u00A0'} e DecidedDate renderiza {formatted ? `Decidida em: ${formatted}` : '\\u00A0'}. Pattern permanece correto: elemento sempre renderizado com placeholder durante SSR/hydration, conteúdo completo (label + data formatada) após dados carregarem.",
      "files_affected": [
        "src/app/(dashboard)/strategic/approvals/page.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-506620",
      "date": "2026-02-07",
      "epic": "E8.5",
      "error": "LOOP PARCIAL identificado: Bug 1) Helper components (SubmittedDate, DecidedDate, DecisionDeadline) continuavam checando strings formatadas {formatted ? ...} ao invés de dados originais {date ? ...}. CAUSA RAIZ: Em LC-327861, assumi incorretamente que helpers não tinham dados originais, mas o parâmetro 'date' É o dado original! Bug 2) ideas e swot usavam new Date().toLocaleString() diretamente em updatedAt, causando hydration mismatch. Bug 3) war-room checava formattedLastUpdate ao invés de lastUpdate original.\"",
      "correction": "CORREÇÃO DEFINITIVA: Bug 1) Substituído {formatted ? ...} por {date ? ...} em 3 helper components com comentários explicativos CRÍTICOS sobre NUNCA checar strings formatadas. Bug 2) Adicionado useClientFormattedDateTime para updatedAt em ideas e swot (era o único campo sem hook correto). Bug 3) Substituído {formattedLastUpdate ? ...} por {lastUpdate.getTime() > 0 ? ...} em war-room. Pattern final IMUTÁVEL: SEMPRE verificar DADOS ORIGINAIS, NUNCA strings formatadas de hooks useSyncExternalStore.\"",
      "files_affected": [
        "src/app/(dashboard)/strategic/approvals/page.tsx",
        "src/app/(dashboard)/strategic/war-room/meetings/[id]/page.tsx",
        "src/app/(dashboard)/strategic/ideas/[id]/page.tsx",
        "src/app/(dashboard)/strategic/swot/[id]/page.tsx",
        "src/app/(dashboard)/strategic/war-room/page.tsx"
      ],
      "pattern_created": "HYDRATION-LOOP-FIX-DEFINITIVE-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-686013",
      "date": "2026-02-07",
      "epic": "E8.5",
      "error": "Bug introduzido em LC-506620: Ao adicionar useClientFormattedDateTime para updatedAt em ideas e swot, usei pattern incorreto {formattedUpdatedAt || '\\u00A0'} que checa string formatada. Mesmo erro que corrigi nos helper components na mesma correção! Durante hydration, hook retorna \"\" no servidor mas valor formatado no cliente, causando conteúdo textual diferente e React Error #418. REGRESSÃO: corrigi o pattern nos helpers mas repeti o erro ao escrever código novo.",
      "correction": "Substituído {formattedUpdatedAt || '\\u00A0'} por {idea?.updatedAt ? formattedUpdatedAt : '\\u00A0'} em ideas/[id] e {swot?.updatedAt ? formattedUpdatedAt : '\\u00A0'} em swot/[id]. Agora verifica dados originais (idea.updatedAt, swot.updatedAt) ao invés de strings formatadas, garantindo conteúdo idêntico durante hydration. LIÇÃO: Pattern IMUTÁVEL deve ser aplicado SEMPRE, inclusive ao escrever código novo durante correções.",
      "files_affected": [
        "src/app/(dashboard)/strategic/ideas/[id]/page.tsx",
        "src/app/(dashboard)/strategic/swot/[id]/page.tsx"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    }
  ]
}