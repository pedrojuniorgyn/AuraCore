{
  "epic": "E7.16",
  "corrections": [
    {
      "id": "LC-170466",
      "date": "2026-01-22",
      "epic": "E7.16",
      "error": "Erro \"e.limit is not a function\" causado pelo uso do método .fetch() que não existe no Drizzle ORM. 3 repositories no módulo Strategic usavam .fetch(N) ao invés de .limit(N), causando runtime error e erros 500 em 4 rotas API.",
      "correction": "Substituído .fetch() por helpers do projeto: queryFirst<T>() para buscar 1 resultado e queryWithLimit<T>(query, limit) para buscar N resultados. Helpers já existentes em src/lib/db/query-helpers.ts com type-safety completo e seguindo padrão LC-001 Contract.",
      "files_affected": [
        "src/modules/strategic/infrastructure/persistence/repositories/DrizzleActionPlanRepository.ts",
        "src/modules/strategic/infrastructure/persistence/repositories/DrizzleActionPlanFollowUpRepository.ts",
        "src/modules/strategic/infrastructure/persistence/repositories/DrizzleWarRoomMeetingRepository.ts"
      ],
      "pattern_created": "P-DB-001: Usar helpers Drizzle (.limit/.offset) via query-helpers.ts",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-816801",
      "date": "2026-01-22",
      "epic": "E7.16",
      "error": "Erro \"Cannot read properties of undefined (reading 'container')\" na inicialização do módulo Fiscal. Import de DrizzleSpedDataRepository estava posicionado DEPOIS da função initializeFiscalSpedModule() que tenta usar a classe, causando classe undefined ao registrar no DI container. Erro aparecia nos logs como: [Instrumentation] Failed to initialize DDD modules: TypeError.",
      "correction": "Movido import de DrizzleSpedDataRepository (e outras classes SPED relacionadas) para o TOPO do arquivo FiscalModule.ts, antes de qualquer função que as utilize. Removido imports duplicados que estavam espalhados pelo arquivo. Ordem correta agora: linha 8 (import) → linha 100 (uso). Seguindo princípio de JavaScript: imports devem estar no escopo antes do uso.",
      "files_affected": [
        "src/modules/fiscal/infrastructure/di/FiscalModule.ts"
      ],
      "pattern_created": "IMPORT-ORDER-001: Imports devem estar no topo do arquivo, antes de qualquer uso",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-746092",
      "date": "2026-01-22",
      "epic": "E7.16",
      "error": "Cache do Next.js em produção causando código antigo ser executado mesmo após git clone correto. Erro \"e.limit is not a function\" persistia nos logs apesar de commits de correção terem sido aplicados. Next.js reutilizava chunks JavaScript antigos da pasta .next/ entre builds consecutivos, ignorando mudanças no código-fonte TypeScript.",
      "correction": "Adicionado comando `RUN rm -rf .next` no Dockerfile (stage builder) ANTES de `npm run build`. Isso força Next.js a recompilar TODOS os chunks JavaScript do zero, eliminando qualquer cache interno. Aumenta tempo de build em ~1min mas garante código sempre sincronizado com repositório.",
      "files_affected": [
        "Dockerfile"
      ],
      "pattern_created": "DOCKER-BUILD-001: Limpar cache do Next.js antes de build em produção",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-252551",
      "date": "2026-01-22",
      "epic": "E7.16",
      "error": "Next.js cache persistente apesar de rm -rf .next. Build com --no-cache e limpeza de .next/ ainda resultava em código antigo sendo executado. Runtime mostrava erros 'e.limit is not a function' mesmo após código-fonte ter sido corrigido no repositório. Next.js 16 possui cache adicional em node_modules/.cache e cache interno de prebundled React que não eram limpos.",
      "correction": "Expandida limpeza de cache no Dockerfile: 1) Adicionar node_modules/.cache na remoção, 2) Usar variável NEXT_PRIVATE_PREBUNDLED_REACT=next durante build para forçar Next.js a recompilar sem cache interno, 3) Garantir que TODOS os níveis de cache sejam eliminados antes do build.",
      "files_affected": [
        "Dockerfile"
      ],
      "pattern_created": "DOCKER-BUILD-002: Limpar cache completo Next.js (incluindo node_modules/.cache e React prebundled)",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-915697",
      "date": "2026-01-22",
      "epic": "E7.16",
      "error": "Erro 500 na inicialização da aplicação (Next.js instrumentation) devido a dependência circular massiva no DI Container. O arquivo container.ts importava todos os módulos, e os módulos importavam container.ts.",
      "correction": "Refatoração da injeção de dependências para eliminar ciclos.\n1. container.ts agora apenas re-exporta tsyringe.\n2. Criado global-registrations.ts para registros globais.\n3. instrumentation.ts orquestra a inicialização sequencial dos módulos.\nIsso resolve o erro 'Cannot register a type name as a singleton without a to token'.",
      "files_affected": [
        "src/shared/infrastructure/di/container.ts",
        "src/shared/infrastructure/di/global-registrations.ts",
        "src/instrumentation.ts"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-041017",
      "date": "2026-01-22",
      "epic": "E7.16",
      "error": "Erro 500 persistente na inicialização: 'tsyringe requires a reflect polyfill'. O polyfill não estava sendo carregado corretamente no contexto do instrumentation em produção.",
      "correction": "Adicionado import 'reflect-metadata' no topo de instrumentation.ts e global-registrations.ts para garantir que o polyfill esteja disponível antes do tsyringe ser invocado no runtime do Next.js (production build).",
      "files_affected": [
        "src/instrumentation.ts",
        "src/shared/infrastructure/di/global-registrations.ts"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-198501",
      "date": "2026-01-22",
      "epic": "E7.16",
      "error": "Erro 500 em várias rotas do módulo Strategic (SWOT, KPIs, Action Plans) com a mensagem 'Attempted to resolve unregistered dependency token'. O registro via { useClass } não estava funcionando corretamente no contexto de produção.",
      "correction": "Atualização do registro de DI no StrategicModule para usar registerSingleton ao invés de register({ useClass }). Isso garante consistência com o restante da aplicação e resolve o erro 'Attempted to resolve unregistered dependency token' causado por falha no registro de classes concretas.",
      "files_affected": [
        "src/modules/strategic/infrastructure/di/StrategicModule.ts"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    }
  ]
}