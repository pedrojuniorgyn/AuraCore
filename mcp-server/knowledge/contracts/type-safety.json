{
  "id": "type-safety",
  "version": "2.0.35",
  "name": "Type Safety Contract",
  "description": "Regras de type safety TypeScript strict",
  "category": "quality",
  "severity": "critical",
  "rules": [
    {
      "id": "TYPE-001",
      "name": "Zero uso de any",
      "description": "NUNCA usar any, nem em testes",
      "pattern": "**/*.ts",
      "forbidden_patterns": [
        ": any",
        "as any",
        "<any>",
        "any[]"
      ],
      "severity": "critical",
      "message": "Proibido usar 'any'. Use tipo explícito ou 'unknown'",
      "alternatives": [
        "unknown - quando tipo é realmente desconhecido",
        "T extends Record<string, unknown> - para objetos genéricos",
        "void - para funções sem retorno",
        "never - para código inalcançável"
      ]
    },
    {
      "id": "TYPE-002",
      "name": "Zero @ts-ignore",
      "description": "NUNCA usar @ts-ignore",
      "pattern": "**/*.ts",
      "forbidden_patterns": [
        "@ts-ignore",
        "// @ts-ignore"
      ],
      "severity": "critical",
      "message": "Proibido @ts-ignore. Corrija o erro de tipo",
      "rationale": "@ts-ignore esconde problemas reais. Se erro de tipo é legítimo, use @ts-expect-error com comentário explicativo."
    },
    {
      "id": "TYPE-003",
      "name": "Tipar retornos de função",
      "description": "SEMPRE tipar retorno de função explicitamente",
      "pattern": "**/*.ts",
      "severity": "high",
      "message": "Função deve ter tipo de retorno explícito",
      "examples": {
        "correct": "function calculate(a: number, b: number): number { ... }",
        "incorrect": "function calculate(a: number, b: number) { ... }"
      },
      "exceptions": [
        "Arrow functions inline em callbacks (map, filter)",
        "Functions com infer de tipo óbvio (getters de 1 linha)"
      ]
    },
    {
      "id": "TYPE-004",
      "name": "Tipar parâmetros",
      "description": "SEMPRE tipar parâmetros de função",
      "pattern": "**/*.ts",
      "severity": "high",
      "message": "Parâmetros devem ter tipo explícito",
      "examples": {
        "correct": "function process(data: ProcessData): void { ... }",
        "incorrect": "function process(data) { ... }"
      }
    },
    {
      "id": "TYPE-005",
      "name": "Validar Result antes de acessar value",
      "description": "SEMPRE verificar Result.isFail() antes de acessar .value",
      "pattern": "**/*.ts",
      "severity": "critical",
      "message": "Verifique Result.isFail() antes de acessar .value",
      "examples": {
        "correct": [
          "if (result.isFail()) return result;",
          "const entity = result.value;"
        ],
        "incorrect": [
          "const entity = result.value; // sem verificar isFail()"
        ]
      }
    },
    {
      "id": "TYPE-006",
      "name": "Null/undefined explícitos",
      "description": "Campos nullable devem usar | null, não ?:",
      "pattern": "**/*.ts",
      "severity": "medium",
      "message": "Use | null para campos opcionais com valor null explícito",
      "rationale": "?: significa undefined, | null significa pode ser null. São semânticas diferentes.",
      "examples": {
        "optional_field": "name?: string // pode estar ausente",
        "nullable_field": "deletedAt: Date | null // está presente mas pode ser null"
      }
    },
    {
      "id": "TYPE-007",
      "name": "Evitar type assertions",
      "description": "Evitar 'as Type' exceto em casos justificados",
      "pattern": "**/*.ts",
      "severity": "high",
      "message": "Evite 'as Type'. Prefira type guards ou validação",
      "allowed_cases": [
        "Casting de unknown após validação",
        "DOM APIs que retornam tipos genéricos",
        "Type narrowing após guard"
      ],
      "forbidden_cases": [
        "as any",
        "as unknown as Type (double cast suspeito)",
        "Contornar erros de tipo legítimos"
      ]
    },
    {
      "id": "TYPE-008",
      "name": "Enums ou Union Types",
      "description": "Use const enum ou union types para valores fixos",
      "pattern": "**/*.ts",
      "severity": "medium",
      "message": "Use enum ou union type ao invés de magic strings",
      "examples": {
        "union_type": "type Status = 'pending' | 'approved' | 'rejected';",
        "const_enum": "const enum Status { Pending = 'pending', Approved = 'approved' }"
      }
    },
    {
      "id": "TYPE-009",
      "name": "Readonly para imutabilidade",
      "description": "Use readonly para propriedades imutáveis",
      "pattern": "domain/value-objects/*.ts",
      "severity": "high",
      "message": "Value Objects devem ter propriedades readonly",
      "examples": {
        "correct": "private readonly props: MoneyProps;",
        "incorrect": "private props: MoneyProps;"
      }
    },
    {
      "id": "TYPE-010",
      "name": "Strict null checks",
      "description": "Compilar com strictNullChecks: true",
      "severity": "critical",
      "message": "tsconfig.json deve ter strictNullChecks: true",
      "config": {
        "compilerOptions": {
          "strict": true,
          "strictNullChecks": true,
          "noImplicitAny": true,
          "strictFunctionTypes": true
        }
      }
    }
  ],
  "tsconfig_required": {
    "strict": true,
    "strictNullChecks": true,
    "noImplicitAny": true,
    "strictFunctionTypes": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  },
  "validation": {
    "pre_commit": "npx tsc --noEmit",
    "expected": "0 errors"
  },
  "rationale": "Type safety previne 60%+ dos bugs em runtime. TypeScript strict mode é fundação de qualidade.",
  "references": [
    "TypeScript Handbook - Strict Mode",
    "Effective TypeScript - Dan Vanderkam"
  ],
  "learned_corrections": [
    {
      "id": "LC-781212",
      "date": "2026-01-07",
      "epic": "E7.15",
      "error": "Interface FiscalDocumentItemRow.net_amount não correspondia à coluna real total_value do banco, causando falha na query SQL do accounting engine",
      "correction": "Revertida correção errada anterior. Alinhado interface (total_value), query SQL (fdi.total_value) e código (item.total_value) com schema real verificado em FiscalDocumentSchema.ts",
      "files_affected": [
        "src/services/accounting-engine.ts"
      ],
      "pattern_created": "VAT-001: Verificar schema real antes de corrigir tipos",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-579143",
      "date": "2026-01-07",
      "epic": "E7.15",
      "error": "Correções ping-pong entre total_value e net_amount devido a schemas conflitantes (ativo vs obsoleto) após migração DDD+Hexagonal. Schema ativo (src/lib/db/schema/accounting.ts) define net_amount, mas schema obsoleto (src/modules/fiscal/.../FiscalDocumentSchema.ts) define total_value",
      "correction": "Investigação completa identificou schema ativo através de src/lib/db/schema.ts. Verificados 20+ arquivos usando net_amount. Aplicada correção definitiva alinhando interface, query SQL e código com net_amount conforme schema ativo",
      "files_affected": [
        "src/services/accounting-engine.ts"
      ],
      "pattern_created": "VAT-012: Schema ativo tem precedência - verificar src/lib/db/schema.ts",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-053509",
      "date": "2026-01-08",
      "epic": "E7.15",
      "error": "Stale closure em useEffect - expandedGroups sempre [] dentro do effect porque não estava nas deps. Causava setState desnecessário a cada mudança de pathname.",
      "correction": "Usar functional update setExpandedGroups(prev => ...) para acessar valor atual sem depender de closure. Adicionar setTimeout para evitar cascading renders (ESLint rule react-hooks/set-state-in-effect).",
      "files_affected": [
        "src/components/layout/grouped-sidebar.tsx"
      ],
      "pattern_created": "React Hooks - Functional Update Pattern",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-053796",
      "date": "2026-01-08",
      "epic": "E7.15",
      "error": "new Date('') cria Invalid Date quando dhEmi/dEmi são undefined no XML da NFe. Causava datas inválidas em parcelas de pagamento.",
      "correction": "Validar issueDateStr antes de chamar parseNFeDate. Se undefined, usar new Date() como fallback. Garantir que parseNFeDate sempre recebe string válida.",
      "files_affected": [
        "src/services/nfe-parser.ts"
      ],
      "pattern_created": "Date Validation Pattern",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-492250",
      "date": "2026-01-10",
      "epic": "E7.15",
      "error": "Bug introduzido em categorias/page.tsx ao corrigir erro TypeScript. Interface FinancialCategory definia type: 'INCOME' | 'EXPENSE' mas o banco retornava 'REVENUE'. Ao corrigir o erro de comparação, removi REVENUE do filtro sem verificar uso no renderizador (linha 215), causando subcontagem no KPI de receitas.",
      "correction": "1. Atualizei interface para incluir REVENUE: type: 'INCOME' | 'REVENUE' | 'EXPENSE'\n2. Restaurei filtro original: c.type === 'INCOME' || c.type === 'REVENUE'\n3. Atualizei formData.type para incluir REVENUE\n4. Apliquei AP-002: Interface DEVE corresponder aos dados reais do banco",
      "files_affected": [
        "src/app/(dashboard)/financeiro/categorias/page.tsx"
      ],
      "pattern_created": "VERIFY-BEFORE-REMOVE: grep patterns before removing logic",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-985888",
      "date": "2026-01-13",
      "epic": "E7.15",
      "error": "Bug de segurança multi-tenancy introduzido ao corrigir erros TypeScript em JournalEntriesController.ts. O branchId foi removido da chamada ao ReverseJournalEntryUseCase, permitindo que usuários de uma filial revertessem lançamentos contábeis de outras filiais da mesma organização. Violação do AP-008: branchId opcional em contexto de segurança.",
      "correction": "1. Adicionado branchId: number à interface ReverseJournalEntryInput\n2. Adicionado validação no UseCase: if (entry.branchId !== BigInt(input.branchId)) return fail\n3. Adicionado branchId no controller: branchId: ctx.branchId\n4. Adicionado branchId na rota API: branchId: session.user.defaultBranchId com validação\n5. Convertido para BigInt na comparação para evitar type mismatch",
      "files_affected": [
        "src/modules/accounting/application/use-cases/ReverseJournalEntryUseCase.ts",
        "src/modules/accounting/presentation/controllers/JournalEntriesController.ts",
        "src/app/api/accounting/journal-entries/[id]/reverse/route.ts"
      ],
      "pattern_created": "VERIFY-BRANCH-ID: Never remove branchId when fixing TypeScript errors",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-144585",
      "date": "2026-01-18",
      "epic": "E7.22.2",
      "error": "Bug 1: Uso de result.isFailure (propriedade) ao invés de Result.isFail(result) (type guard com método estático). Bug 2: NFCE faltando no enum e validação do MCP server para validate_fiscal_compliance.",
      "correction": "Bug 1: Alterado result.isFailure para Result.isFail(result) na linha 115 do generate-titles/route.ts. Bug 2: Adicionado 'nfce' ao enum na linha 241 e ao validFeatureTypes na linha 746 do mcp-server/src/server.ts.",
      "files_affected": [
        "src/app/api/fiscal/documents/[id]/generate-titles/route.ts",
        "mcp-server/src/server.ts"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-844126",
      "date": "2026-01-18",
      "epic": "E-Agent-Fase2",
      "error": "Promise aninhada no método executeTool - faltava await antes de tool.call(), causando retorno Promise&lt;Promise&lt;ToolResult&gt;&gt;",
      "correction": "Adicionado await antes de tool.call(input, this.executionContext)",
      "files_affected": [
        "src/agent/core/AuraAgent.ts"
      ],
      "pattern_created": "P-ASYNC-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-165549",
      "date": "2026-01-18",
      "epic": "E-Agent-Fase4",
      "error": "Mutação direta do estado em nodos do workflow LangGraph - state.status = 'fetching' e state.errors.push() dentro de funções de nodo, violando o padrão de funções puras",
      "correction": "Removidas mutações diretas do parâmetro state. Agora todas as mudanças são retornadas via Partial<State> ou aplicadas via applyResult(). Logs usam spread operator [...state.logs, newLog]",
      "files_affected": [
        "src/agent/workflows/BankReconciliationWorkflow.ts"
      ],
      "pattern_created": "P-WORKFLOW-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-288236",
      "date": "2026-01-18",
      "epic": "E7.26",
      "error": "Output Ports com branchId opcional (VIOLAÇÃO ENFORCE-004) em IPayableRepository e IJournalEntryRepository. Métodos findById, exists, findBySupplier, findByPeriod, findBySourceId não exigiam branchId. TOKENS faltantes para TaxRateRepository, TaxCreditRepository e RomaneioRepository.",
      "correction": "1) IPayableRepository: branchId obrigatório em FindPayablesFilter e todos os métodos (findById, findOverdue, findBySupplier, exists). 2) IJournalEntryRepository: branchId obrigatório em FindJournalEntriesFilter e todos os métodos (findById, findByPeriod, findBySourceId, exists). 3) DrizzlePayableRepository: atualizado para incluir branchId em todas as queries. 4) Use Cases de Accounting e Financial: atualizados para passar ctx.branchId em todas as chamadas de repositório. 5) TOKENS: adicionados TaxRateRepository, TaxCreditRepository e RomaneioRepository.",
      "files_affected": [
        "src/modules/financial/domain/ports/output/IPayableRepository.ts",
        "src/modules/accounting/domain/ports/output/IJournalEntryRepository.ts",
        "src/modules/financial/infrastructure/persistence/DrizzlePayableRepository.ts",
        "src/modules/accounting/application/use-cases/AddLineToEntryUseCase.ts",
        "src/modules/accounting/application/use-cases/GetJournalEntryByIdUseCase.ts",
        "src/modules/accounting/application/use-cases/ListJournalEntriesUseCase.ts",
        "src/modules/accounting/application/use-cases/PostJournalEntryUseCase.ts",
        "src/modules/accounting/application/use-cases/ReverseJournalEntryUseCase.ts",
        "src/modules/financial/application/use-cases/CancelPayableUseCase.ts",
        "src/modules/financial/application/use-cases/GetPayableByIdUseCase.ts",
        "src/modules/financial/application/use-cases/ListPayablesUseCase.ts",
        "src/modules/financial/application/use-cases/PayAccountPayableUseCase.ts",
        "src/shared/infrastructure/di/tokens.ts"
      ],
      "pattern_created": "P-MULTITENANCY-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-306581",
      "date": "2026-01-19",
      "epic": "E-Agent-Fase6",
      "error": "Bug 1: Paginação ineficiente no listSessions - buscava todas as sessões e fazia slice em memória. Bug 2: Bypass de multi-tenancy no getMessages - não validava se a sessão pertencia ao tenant. Bug 3: Stale closure no useAgentChat - loadSession não estava memoizada com useCallback.",
      "correction": "Bug 1: Implementado OFFSET/FETCH NEXT no SQL com COUNT separado para paginação correta. Bug 2: Adicionado organizationId e branchId como parâmetros obrigatórios em getMessages com verificação prévia de pertencimento ao tenant. Bug 3: Memoizado loadSession com useCallback e adicionado às dependências do useEffect.",
      "files_affected": [
        "src/agent/persistence/SessionStore.ts",
        "src/app/api/agent/sessions/[sessionId]/route.ts",
        "src/hooks/useAgentChat.ts"
      ],
      "pattern_created": "P-SEC-001: Multi-tenancy obrigatório em getMessages, P-PERF-001: Paginação no SQL, P-REACT-001: useCallback para funções em useEffect",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-366609",
      "date": "2026-01-19",
      "epic": "E7.27",
      "error": "Interfaces IJournalEntryRepository duplicadas com propósitos diferentes causando confusão arquitetural. A interface legada (ports/IJournalEntryRepository.ts) era para contabilização fiscal enquanto a DDD (ports/output/IJournalEntryRepository.ts) era para CRUD de Entity.",
      "correction": "Renomeou interface legada para IFiscalAccountingRepository, criou implementação DDD real do IJournalEntryRepository, atualizou DI para registrar ambos corretamente, atualizou todos os imports e consumidores.",
      "files_affected": [
        "src/modules/accounting/domain/ports/IFiscalAccountingRepository.ts",
        "src/modules/accounting/domain/ports/index.ts",
        "src/modules/accounting/infrastructure/persistence/DrizzleFiscalAccountingRepository.ts",
        "src/modules/accounting/infrastructure/persistence/DrizzleJournalEntryRepository.ts",
        "src/modules/accounting/infrastructure/di/AccountingModule.ts",
        "src/modules/accounting/application/use-cases/GenerateJournalEntryUseCase.ts",
        "src/shared/infrastructure/di/tokens.ts"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-094913",
      "date": "2026-01-19",
      "epic": "D1",
      "error": "Bug no DoclingClient.fetchWithRetry: quando erro 5xx na última tentativa de retry, o código não retornava Result.fail() e tentava fazer response.json() novamente, causando erro 'Cannot read properties of undefined'",
      "correction": "Adicionado return Result.fail(lastError) após verificar que é a última tentativa em caso de erro 5xx, garantindo que o fluxo não continue para response.json() após erro",
      "files_affected": [
        "src/shared/infrastructure/docling/DoclingClient.ts"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-257847",
      "date": "2026-01-19",
      "epic": "D1",
      "error": "Build falhando no Coolify: tsyringe requires a reflect polyfill. Os arquivos importavam diretamente de 'tsyringe' sem garantir que reflect-metadata fosse carregado primeiro. Isso causava erro durante npm run build no Next.js 16 com Turbopack.",
      "correction": "1) Expandido container.ts para re-exportar injectable, inject, singleton, etc do tsyringe após importar reflect-metadata. 2) Alterados 106 arquivos para importar de '@/shared/infrastructure/di/container' em vez de 'tsyringe'. Isso garante que reflect-metadata seja sempre carregado primeiro.",
      "files_affected": [
        "src/shared/infrastructure/di/container.ts",
        "src/app/api/**/*.ts (24 rotas)",
        "src/modules/**/use-cases/*.ts (50+ arquivos)",
        "src/modules/**/di/*.ts (7 módulos)",
        "src/modules/**/persistence/*.ts (10 repositórios)",
        "src/modules/**/adapters/*.ts (8 adapters)"
      ],
      "pattern_created": "P-DI-001: Import tsyringe from container",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-740883",
      "date": "2026-01-19",
      "epic": "E8.4",
      "error": "Migration de índices com colunas inexistentes - schema Drizzle divergente do banco real. Migration 0034 referenciava branch_id e deleted_at em tabelas que não tinham essas colunas.",
      "correction": "Auditoria completa do schema antes de criar migrations. Validar colunas com INFORMATION_SCHEMA antes de criar índices. Criar migration 0036 com índices corrigidos.",
      "files_affected": [
        "drizzle/migrations/0034_add_tenant_indexes.sql",
        "drizzle/migrations/0036_fix_tenant_indexes.sql"
      ],
      "pattern_created": "P-MIGRATION-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-743510",
      "date": "2026-01-19",
      "epic": "E8.4",
      "error": "drizzle-kit push executado sem validação causou DATA LOSS em tabelas de produção. Comando destrutivo deletou tabelas existentes.",
      "correction": "NUNCA usar drizzle-kit push em produção/homologação. Usar apenas migrations SQL manuais revisadas. Adicionar validação prévia obrigatória.",
      "files_affected": [
        "drizzle/migrations/*"
      ],
      "pattern_created": "P-MIGRATION-002",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-745627",
      "date": "2026-01-19",
      "epic": "E8.4",
      "error": "Índices filtrados (WHERE deleted_at IS NULL) falham sem SET QUOTED_IDENTIFIER ON no SQL Server",
      "correction": "Toda migration SQL deve iniciar com SET QUOTED_IDENTIFIER ON; SET ANSI_NULLS ON; antes de qualquer comando.",
      "files_affected": [
        "drizzle/migrations/*"
      ],
      "pattern_created": "P-MIGRATION-003",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-335685",
      "date": "2026-01-19",
      "epic": "E9.3",
      "error": "APIs não filtravam por branchId (REPO-005) e deletedAt IS NULL (REPO-006) violando regras de multi-tenancy e soft delete. TenantContext não tinha branchId obrigatório.",
      "correction": "Adicionado branchId ao TenantContext. Corrigidas 10 APIs para filtrar por branchId + deletedAt IS NULL em queries e incluir branchId em inserts.",
      "files_affected": [
        "src/lib/auth/context.ts",
        "src/app/api/financial/bank-transactions/route.ts",
        "src/app/api/fleet/fuel/route.ts",
        "src/app/api/fleet/drivers/route.ts",
        "src/app/api/fleet/vehicles/route.ts",
        "src/app/api/products/route.ts",
        "src/app/api/financial/cost-centers/route.ts",
        "src/app/api/fiscal/settings/route.ts",
        "src/app/api/fleet/maintenance/work-orders/route.ts",
        "src/app/api/financial/remittances/generate/route.ts"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-509306",
      "date": "2026-01-19",
      "epic": "E10-F2",
      "error": "1) DrizzleStrategicGoalRepository implementava métodos não definidos na interface (violação ARCH-011). 2) Código morto em [id]/route.ts verificando /activate que já é tratado em arquivo dedicado.",
      "correction": "1) Adicionados métodos findByCascadeLevel e findRootGoals na interface IStrategicGoalRepository. 2) Removido código duplicado de /activate em [id]/route.ts.",
      "files_affected": [
        "src/modules/strategic/domain/ports/output/IStrategicGoalRepository.ts",
        "src/app/api/strategic/strategies/[id]/route.ts"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-628225",
      "date": "2026-01-19",
      "epic": "E10-F4",
      "error": "SyncKPIValuesUseCase tinha Map<string, IKPIDataSource> que nunca era populado. O método registerDataSource() existia mas nunca era chamado, causando 100% de falha em sincronizações automáticas de KPI com erro 'Fonte de dados não registrada'.",
      "correction": "Injetados FinancialKPIDataSource e TMSKPIDataSource via constructor usando DI (@inject). Map inicializado no constructor com os DataSources injetados usando moduleName como chave. Método registerDataSource() removido.",
      "files_affected": [
        "src/modules/strategic/application/commands/SyncKPIValuesUseCase.ts"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-702579",
      "date": "2026-01-20",
      "epic": "E8",
      "error": "list_integrations endpoint não passava branch_id para o hub, violando regra ARCH-006 de multi-tenancy obrigatório",
      "correction": "Adicionado branch_id=auth[\"branch_id\"] na chamada hub.list_integrations() para garantir filtragem por filial",
      "files_affected": [
        "agents/src/api/integrations.py"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-113889",
      "date": "2026-01-20",
      "epic": "E8",
      "error": "DurationTracker.__aexit__ usa self._start_time sem verificar se é None. Se __aenter__ falhar ou não for chamado, __aexit__ crashará com TypeError: unsupported operand type(s) for -: 'float' and 'NoneType'",
      "correction": "Adicionado null check para _start_time antes de calcular duration. Se _start_time é None, usa 0.0 como fallback e emite warning via logger",
      "files_affected": [
        "agents/src/services/analytics/event_tracker.py"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-375756",
      "date": "2026-01-20",
      "epic": "E9",
      "error": "Bug E9-002: Commercial calculate endpoint usava organizationId=1 e branchId=1 como defaults hardcoded, permitindo acesso sem autenticação",
      "correction": "Adicionado getTenantContext() para validar autenticação. IDs agora vêm do usuário autenticado, NUNCA do body",
      "files_affected": [
        "src/app/api/commercial/calculate/route.ts"
      ],
      "pattern_created": "tenant-security",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-378597",
      "date": "2026-01-20",
      "epic": "E9",
      "error": "Bug E9-003: Query após insert em proposals/route.ts filtrava apenas por id, sem organizationId, permitindo acesso cross-tenant",
      "correction": "Adicionado import de 'and' e filtro organizationId na query: and(eq(id), eq(organizationId))",
      "files_affected": [
        "src/app/api/comercial/proposals/route.ts"
      ],
      "pattern_created": "tenant-security",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-084086",
      "date": "2026-01-20",
      "epic": "E9",
      "error": "Bug LC-381234: readOnlyRootFilesystem no Kubernetes deployment sem volume para /app/data, causaria falha de escrita em runtime",
      "correction": "Adicionado volume emptyDir para /app/data nos volumeMounts e volumes do deployment.yaml",
      "files_affected": [
        "agents/k8s/deployment.yaml"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-284838",
      "date": "2026-01-20",
      "epic": "E9",
      "error": "Bug CI-001: Build do Dockerfile dos agents falhava com 'OSError: Readme file does not exist: README.md' porque o pyproject.toml declara readme=\"README.md\" mas o Dockerfile só copiava pyproject.toml antes do pip install, não incluindo o README.md necessário pelo hatchling",
      "correction": "Corrigido Dockerfile para copiar README.md junto com pyproject.toml antes do pip install. Também corrigido: versão Python (3.12→3.11 para compatibilidade), removido Poetry (projeto usa hatchling), corrigido casing de AS para padrão (as→AS), removido COPY de .venv inexistente",
      "files_affected": [
        "agents/Dockerfile"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-689836",
      "date": "2026-01-21",
      "epic": "E9",
      "error": "Bug CI-002: hatchling não conseguia encontrar arquivos para build porque faltava configuração [tool.hatch.build.targets.wheel] no pyproject.toml. O projeto usa estrutura src/ mas hatchling procurava por auracore_agents/",
      "correction": "Adicionado [tool.hatch.build.targets.wheel] com packages = ['src'] e [tool.hatch.build.targets.sdist] com include list no pyproject.toml",
      "files_affected": [
        "agents/pyproject.toml"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-692590",
      "date": "2026-01-21",
      "epic": "E9",
      "error": "Bug K8S-001: Volume data usando emptyDir causa perda de dados em restart/scale-down. App armazena SQLite/ChromaDB em /app/data/memory para sessões persistentes, mas Deployment com HPA (3-10 replicas) com emptyDir perde todos os dados quando pods são recriados",
      "correction": "Adicionado WARNING comentário no deployment.yaml explicando o problema e opções (PVC, StatefulSet, Redis externo). Criado pvc-data.yaml como template opcional para produção",
      "files_affected": [
        "agents/k8s/deployment.yaml",
        "agents/k8s/pvc-data.yaml"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-997538",
      "date": "2026-01-21",
      "epic": "E9",
      "error": "Interface Contract em get-contract-tool.ts validava 'title' como campo obrigatório, mas todos os JSONs de contratos usam 'name'. Causava erro 'Invalid contract schema' ao chamar get_contract para qualquer contrato.",
      "correction": "1) Alterada interface Contract para usar 'name' como campo principal e 'title' como alias opcional. 2) Alterada validação para aceitar (!contract.name && !contract.title). 3) Corrigidos listContracts() e searchContracts() em contracts.ts para usar fallback name || title || id.",
      "files_affected": [
        "mcp-server/src/tools/get-contract-tool.ts",
        "mcp-server/src/resources/contracts.ts"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-194349",
      "date": "2026-01-21",
      "epic": "E10.1",
      "error": "Arquivo sefaz-processor.ts importava funções extractCargoInfo e estimateDeliveryDeadline do arquivo nfe-classifier.ts deletado",
      "correction": "Removida importação não utilizada - as funções eram importadas mas nunca chamadas no código",
      "files_affected": [
        "src/services/sefaz-processor.ts"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-272090",
      "date": "2026-01-21",
      "epic": "E9",
      "error": "Bug 'Cannot read properties of undefined (reading toFixed)' na página /financeiro/dre-dashboard. O componente NumberCounter em magic-components.tsx chamava value.toFixed(decimals) sem verificar se value era undefined/null/NaN. Quando dados do DRE vinham vazios ou com campos undefined da API, o componente quebrava.",
      "correction": "1) Alterado type do prop value em NumberCounter para aceitar 'number | undefined | null'. 2) Adicionado safeValue = value ?? 0 e numericValue = Number.isFinite(safeValue) ? safeValue : 0. 3) Alterado useEffect para usar numericValue ao invés de value. 4) Adicionado displayValue = Number.isFinite(count) ? count : 0 antes do toFixed(). 5) Corrigido também dre/page.tsx com (margin ?? 0) em 3 ocorrências preventivamente.",
      "files_affected": [
        "src/components/ui/magic-components.tsx",
        "src/app/(dashboard)/financeiro/dre/page.tsx"
      ],
      "pattern_created": "P-SAFE-TOFIX: Always protect toFixed with nullish coalescing",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-049769",
      "date": "2026-01-21",
      "epic": "E10.2.1",
      "error": "SQL Injection: Queries SQL usavam string interpolation com dados de veículos e planos (organization_id, vehicle_id, plan_id, model, trigger_type, alertMessage) ao invés de queries parametrizadas",
      "correction": "Todas as queries agora usam pool.request().input() para parâmetros e @nomeParam na query. Dados usados em logs são sanitizados com .replace(/['\\\"]/g, '')",
      "files_affected": [
        "src/modules/fleet/infrastructure/jobs/CheckMaintenanceAlertsJob.ts"
      ],
      "pattern_created": "SQL-PARAM-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-052872",
      "date": "2026-01-21",
      "epic": "E10.2.1",
      "error": "Flag initialized só era setada no final do bloco de criação de jobs, permitindo chamadas duplicadas durante early returns (build phase, cron disabled)",
      "correction": "Flag initialized = true movida para LOGO APÓS a verificação if(initialized), antes dos early returns condicionais. Isso previne chamadas concorrentes/duplicadas",
      "files_affected": [
        "src/lib/cron-setup.ts"
      ],
      "pattern_created": "INIT-FLAG-001",
      "status": "APPROVED",
      "must_not_repeat": true
    },
    {
      "id": "LC-364159",
      "date": "2026-01-21",
      "epic": "HOTFIX-STRATEGIC-500",
      "error": "Agente não seguiu ordem correta de debug para erro 500. Verificou rotas antes de verificar schema exports, causando delay na identificação da causa raiz (schema do módulo Strategic não exportado em src/lib/db/schema.ts). Estatística mostra que 80% dos erros 500 em módulos novos são por schema não exportado, mas não havia checklist documentado.",
      "correction": "Criado contrato DEBUG_500_CONTRACT.md com checklist obrigatório de 5 passos priorizados por probabilidade: 1) Schema exports (80%), 2) DI registration (10%), 3) Database tables (5%), 4) Environment vars (3%), 5) Route handlers (2%). Atualizado regrasmcp.mdc com regras DEBUG-500-001 a DEBUG-500-005 e script rápido de diagnóstico. Documentado fluxograma de debug e exemplos reais do incidente.",
      "files_affected": [
        "docs/architecture/contracts/DEBUG_500_CONTRACT.md",
        ".cursor/rules/regrasmcp.mdc"
      ],
      "pattern_created": null,
      "status": "APPROVED",
      "must_not_repeat": true
    }
  ]
}